; ---------------------------------------------------------------------------- ;
;    Лабораторная работа №1 по курсу Программирование на языке ассемблера      ;
;    Вариант №8.                                                               ;
;    Выполнил студент Демьяненко И. Группа 344                                 ;
;                                                                              ;
;    Исходный модуль Lab1Func_Demyanenko_08.asm                                ;
;    Содержит реализованные функции в соответствии с заданием                  ;
; ---------------------------------------------------------------------------- ;
;    Задание:                                                                  ;
;        Реализовать операторы класса, представляющего собой четыре 32-битных  ;
;        целых со знаком с параллельной арифметикой насыщения                  ;
.DATA
bitmask     qword 8000000080000000h
antibitmask qword 7FFFFFFF7FFFFFFFh
.CODE
; ---------------------------------------------------------------------------- ;
; Макропроцедура вычисляет сумму двух знаковых 32-разрядных слагаемых a и b и  ;
; записывает результат в sum                                                   ;
; ---------------------------------------------------------------------------- ;
add2x32 MACRO a, b, sum
    ; Маска одинаковости знаков операндов
    mov rax, a
    xor rax, b
    not rax
    and rax, bitmask
    
    ; Маска отрицательности одного из операндов
    mov r9, a
    or  r9, b
    and r9, bitmask

    ; Сложение без знака
    mov r10, a
    and r10, antibitmask
    mov r13, b
    and r13, antibitmask
    add r10, r13

    ; Проверить на переполнение в отрицательную сторону ('-' + '-' = '+')
    mov r11, rax
    and r11, r9
    mov r13, r10
    not r13
    and r11, r13 ; Старший бит составляющей r11 – индикатор переполнения
                 ; этой составляющей в r10

    ; Вычислить маску переполнения
    mov r12, r11
    shl r12, 1
    mov r13, r11
    shr r13, 31
    sub r12, r13
    not r12      ; Если составляющая суммы переполнилась, то соответствующая
                 ; ей часть маски заполнена единицами. Если нет, то нулями.

    ; Применить маску переполнения
    and r10, r12

    ; Заменить переполненную часть суммы на 10...0
    ; (совпадает с маской переполнения)
    or  r10, r11

    ; Проверить на переполнение в положительную сторону ('+' + '+' = '-')
    mov r11, rax
    and r11, r10
    mov r13, r9
    not r13
    and r11, r13 ; Старший бит составляющей r11 – индикатор переполнения
                 ; этой составляющей в r10

    ; Вычислить маску переполнения (r12)
    mov r12, r11
    shl r12, 1
    mov r13, r11
    shr r13, 31
    sub r12, r13
    not r12      ; Если составляющая суммы переполнилась, то соответствующая
                 ; ей часть маски заполнена единицами. Если нет, то нулями.
    
    ; Применить маску переполнения
    and r10, r12
    
    ; Заменить переполненную часть суммы на 01...1
    not r12
    xor r12, r11
    or  r10, r12

    ; Восстановить знак составляющей суммы, если операнды были разных знаков
    xor rax, bitmask
    xor r10, rax

    ; Записать результат
    mov sum, r10
ENDM

; ---------------------------------------------------------------------------- ;
; Вычисляет сумму четырёх знаковых 32-разрядных слагаемых a и b и записывает   ;
; результат в sum                                                              ;
; void add4x32(__int32* sum, __int32* a, __int32* b)                           ;
; ---------------------------------------------------------------------------- ;
add4x32 PROC ; RCX - *sum
             ; RDX - *a
             ; R8  - *b
    push r12
    push r13
    push r14
    push r15
    push rbx
    push rbp
    push rdi
    push rsi

    mov r14, [rdx]
    mov r15, [rdx+8]
    mov rbx, [r8]
    mov rbp, [r8+8]

    add2x32 r14, rbx, rdi ; Параллельное сложение первых двух операндов
    add2x32 r15, rbp, rsi ; Параллельное сложение вторых двух операндов

    mov [rcx], rdi
    mov [rcx+8], rsi

    pop rsi
    pop rdi
    pop rbp
    pop rbx
    pop r15
    pop r14
    pop r13
    pop r12

    ret
add4x32 ENDP

; ---------------------------------------------------------------------------- ;
; Макропроцедура вычисляет разность двух знаковых 32-разрядных слагаемых a и b ;
; и записывает результат в dif                                                 ;
; ---------------------------------------------------------------------------- ;
sub2x32 MACRO a, b, dif
    ; Вычесть с защитой от заёма
    mov rax, a
    or  rax, bitmask
    mov r13, b
    and r13, antibitmask
    sub rax, r13
    xor rax, bitmask

    ; Знак первого операнда
    mov r9, a
    and r9, bitmask

    ; Знак второго операнда
    mov r10, b
    and r10, bitmask

    ; Восстановить знак суммы
    xor rax, r9
    xor rax, r10

    ; Проверить на переполнение в положительную сторону ('+' - '-' = '-')
    mov r11, r9
    not r11
    and r11, r10
    and r11, rax ; Старший бит составляющей r11 – индикатор переполнения
                 ; этой составляющей в rax

    ; Вычислить маску переполнения
    mov r12, r11
    shl r12, 1
    mov r13, r11
    shr r13, 31
    sub r12, r13 ; Если составляющая суммы переполнилась, то соответствующая
                 ; ей часть маски заполнена единицами. Если нет, то нулями.

    ; Заменить переполненную вверх составляющую на 01...1
    or  rax, r12
    xor rax, r11

    ; Проверить на переполнение в отрицательную сторону ('-' - '+' = '+')
    mov r11, r9
    mov r13, r10
    not r13
    and r11, r13
    mov r13, rax
    not r13
    and r11, r13 ; Старший бит составляющей r11 – индикатор переполнения
                 ; этой составляющей в rax

    ; Вычислить маску переполнения
    mov r12, r11
    shl r12, 1
    mov r13, r11
    shr r13, 31
    sub r12, r13
    not r12      ; Если составляющая суммы переполнилась, то соответствующая
                 ; ей часть маски заполнена единицами. Если нет, то нулями.
    
    ; Заменить переполненную вниз составляющую на 10...0
    and rax, r12
    or rax, r11

    ; Записать результат
    mov dif, rax
ENDM

; ---------------------------------------------------------------------------- ;
; Вычисляет разность четырёх знаковых 32-разрядных слагаемых a и b и           ;
; записывает результат в dif                                                   ;
; void sub4x32(__int32* dif, __int32* a, __int32* b)                           ;
; ---------------------------------------------------------------------------- ;
sub4x32 PROC ; RCX - *dif
             ; RDX - *a
             ; R8  - *b
    push r12
    push r13
    push r14
    push r15
    push rbx
    push rbp
    push rdi
    push rsi

    mov r14, [rdx]
    mov r15, [rdx+8]
    mov rbx, [r8]
    mov rbp, [r8+8]

    sub2x32 r14, rbx, rdi ; Параллельное вычитание первых двух операндов
    sub2x32 r15, rbp, rsi ; Параллельное вычитание вторых двух операндов

    mov [rcx], rdi
    mov [rcx+8], rsi

    pop rsi
    pop rdi
    pop rbp
    pop rbx
    pop r15
    pop r14
    pop r13
    pop r12

    ret
sub4x32 ENDP
END