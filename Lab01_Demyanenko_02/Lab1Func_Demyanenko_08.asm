; ---------------------------------------------------------------------------- ;
;    Лабораторная работа №1 по курсу Программирование на языке ассемблера      ;
;    Вариант №8.                                                               ;
;    Выполнил студент Демьяненко И. Группа 344                                 ;
;                                                                              ;
;    Исходный модуль Lab1Func_Demyanenko_08.asm                                ;
;    Содержит реализованные функции в соответствии с заданием                  ;
; ---------------------------------------------------------------------------- ;
;    Задание:                                                                  ;
;        Реализовать операторы класса, представляющего собой четыре 32-битных  ;
;        целых со знаком с параллельной арифметикой насыщения                  ;
.DATA
bitmask       qword 8000000080000000h
antibitmask   qword 7FFFFFFF7FFFFFFFh
bitmask32     dword 80000000h
antibitmask32 dword 7FFFFFFFh
.CODE
; ---------------------------------------------------------------------------- ;
; Макропроцедура вычисляет сумму двух пар знаковых 32-разрядных слагаемых      ;
; a и b и записывает результат в sum                                                   ;
; ---------------------------------------------------------------------------- ;
add2x32 MACRO a, b, sum
    ; Маска одинаковости знаков операндов
    mov rax, a
    xor rax, b
    not rax
    and rax, bitmask
    
    ; Маска отрицательности одного из операндов
    mov r9, a
    or  r9, b
    and r9, bitmask

    ; Сложение без знака
    mov r10, a
    and r10, antibitmask
    mov r13, b
    and r13, antibitmask
    add r10, r13

    ; Проверить на переполнение в отрицательную сторону ('-' + '-' = '+')
    mov r11, rax
    and r11, r9
    mov r13, r10
    not r13
    and r11, r13 ; Старший бит составляющей r11 – индикатор переполнения
                 ; этой составляющей в r10

    ; Вычислить маску переполнения
    mov r12, r11
    shl r12, 1
    mov r13, r11
    shr r13, 31
    sub r12, r13
    not r12      ; Если составляющая суммы переполнилась, то соответствующая
                 ; ей часть маски заполнена единицами. Если нет, то нулями.

    ; Применить маску переполнения
    and r10, r12

    ; Заменить переполненную часть суммы на 10...0
    ; (совпадает с маской переполнения)
    or  r10, r11

    ; Проверить на переполнение в положительную сторону ('+' + '+' = '-')
    mov r11, rax
    and r11, r10
    mov r13, r9
    not r13
    and r11, r13 ; Старший бит составляющей r11 – индикатор переполнения
                 ; этой составляющей в r10

    ; Вычислить маску переполнения (r12)
    mov r12, r11
    shl r12, 1
    mov r13, r11
    shr r13, 31
    sub r12, r13
    not r12      ; Если составляющая суммы переполнилась, то соответствующая
                 ; ей часть маски заполнена единицами. Если нет, то нулями.
    
    ; Применить маску переполнения
    and r10, r12
    
    ; Заменить переполненную часть суммы на 01...1
    not r12
    xor r12, r11
    or  r10, r12

    ; Восстановить знак составляющей суммы, если операнды были разных знаков
    xor rax, bitmask
    xor r10, rax

    ; Записать результат
    mov sum, r10
ENDM

; ---------------------------------------------------------------------------- ;
; Вычисляет сумму четырёх пар знаковых 32-разрядных слагаемых a и b и          ;
; записывает результат в sum                                                   ;
; void add4x32(__int32* sum, __int32* a, __int32* b)                           ;
; ---------------------------------------------------------------------------- ;
add4x32 PROC ; RCX - *sum
             ; RDX - *a
             ; R8  - *b
    push r12
    push r13
    push r14
    push r15
    push rbx
    push rbp
    push rdi
    push rsi

    mov r14, [rdx]
    mov r15, [rdx+8]
    mov rbx, [r8]
    mov rbp, [r8+8]

    add2x32 r14, rbx, rdi ; Параллельное сложение первых двух операндов
    add2x32 r15, rbp, rsi ; Параллельное сложение вторых двух операндов

    mov [rcx], rdi
    mov [rcx+8], rsi

    pop rsi
    pop rdi
    pop rbp
    pop rbx
    pop r15
    pop r14
    pop r13
    pop r12

    ret
add4x32 ENDP

; ---------------------------------------------------------------------------- ;
; Макропроцедура вычисляет разность двух пар знаковых 32-разрядных слагаемых   ;
; a и b и записывает результат в diff                                          ;
; ---------------------------------------------------------------------------- ;
sub2x32 MACRO a, b, diff
    ; Вычесть с защитой от заёма
    mov rax, a
    or  rax, bitmask
    mov r13, b
    and r13, antibitmask
    sub rax, r13
    xor rax, bitmask

    ; Знак первого операнда
    mov r9, a
    and r9, bitmask

    ; Знак второго операнда
    mov r10, b
    and r10, bitmask

    ; Восстановить знак суммы
    xor rax, r9
    xor rax, r10

    ; Проверить на переполнение в положительную сторону ('+' - '-' = '-')
    mov r11, r9
    not r11
    and r11, r10
    and r11, rax ; Старший бит составляющей r11 – индикатор переполнения
                 ; этой составляющей в rax

    ; Вычислить маску переполнения
    mov r12, r11
    shl r12, 1
    mov r13, r11
    shr r13, 31
    sub r12, r13 ; Если составляющая суммы переполнилась, то соответствующая
                 ; ей часть маски заполнена единицами. Если нет, то нулями.

    ; Заменить переполненную вверх составляющую на 01...1
    or  rax, r12
    xor rax, r11

    ; Проверить на переполнение в отрицательную сторону ('-' - '+' = '+')
    mov r11, r9
    mov r13, r10
    not r13
    and r11, r13
    mov r13, rax
    not r13
    and r11, r13 ; Старший бит составляющей r11 – индикатор переполнения
                 ; этой составляющей в rax

    ; Вычислить маску переполнения
    mov r12, r11
    shl r12, 1
    mov r13, r11
    shr r13, 31
    sub r12, r13
    not r12      ; Если составляющая суммы переполнилась, то соответствующая
                 ; ей часть маски заполнена единицами. Если нет, то нулями.
    
    ; Заменить переполненную вниз составляющую на 10...0
    and rax, r12
    or rax, r11

    ; Записать результат
    mov diff, rax
ENDM

; ---------------------------------------------------------------------------- ;
; Вычисляет разность четырёх пар знаковых 32-разрядных слагаемых a и b и       ;
; записывает результат в diff                                                  ;
; void sub4x32(__int32* diff, __int32* a, __int32* b)                          ;
; ---------------------------------------------------------------------------- ;
sub4x32 PROC ; RCX - *diff
             ; RDX - *a
             ; R8  - *b
    push r12
    push r13
    push r14
    push r15
    push rbx
    push rbp
    push rdi
    push rsi

    mov r14, [rdx]
    mov r15, [rdx+8]
    mov rbx, [r8]
    mov rbp, [r8+8]

    sub2x32 r14, rbx, rdi ; Параллельное вычитание первых двух операндов
    sub2x32 r15, rbp, rsi ; Параллельное вычитание вторых двух операндов

    mov [rcx], rdi
    mov [rcx+8], rsi

    pop rsi
    pop rdi
    pop rbp
    pop rbx
    pop r15
    pop r14
    pop r13
    pop r12

    ret
sub4x32 ENDP

; ---------------------------------------------------------------------------- ;
; Макропроцедура вычисляет произведение двух знаковых 32-разрядных множителей  ;
; eax и b и записывает результат в eax                                         ;
; Вынужденно использует регистр edx                                            ;
; Использует регистр r14                                                       ;
; ---------------------------------------------------------------------------- ;
mul1x32 MACRO b
    ; Перемножить eax и b с расширением на edx
    imul b

    setc r14b

    ; Преобразовать знак старшей части произведения
    ; в максимальное или минимальное число
    ; 0... -> 01...1
    ; 1... -> 10...0
    sar edx, 31
    xor edx, antibitmask32

    ; Если было переполнение, выполнить насыщение eax
    cmp r14b, 1
    cmovz eax, edx
ENDM

; ---------------------------------------------------------------------------- ;
; Вычисляет произведение четырёх пар знаковых 32-разрядных множителей a и b и  ;
; записывает результат в prod                                                  ;
; void sub4x32(__int32* prod, __int32* a, __int32* b)                          ;
; ---------------------------------------------------------------------------- ;
mul4x32 PROC ; RCX - *prod
             ; RDX - *a
             ; R8  - *b
    push rbx
    push r12
    push r13
    push r14

    mov rbx, [rdx]
    mov r9, [rdx+8]
    mov r10, [r8]
    mov r11, [r8+8]
    
    ; Записать произведение первых двух операндов в младшую половину r12
    mov eax, ebx
    mul1x32 r10d
    mov r12d, eax

    ; Записать произведение вторых двух операндов в старшую половину r12
    shr rbx, 32
    shr r10, 32
    mov eax, ebx
    mul1x32 r10d
    shl rax, 32
    or  r12, rax
    
    ; Записать произведение третьих двух операндов в младшую половину r13
    mov eax, r9d
    mul1x32 r11d
    mov r13d, eax

    ; Записать произведение четвёртых двух операндов в старшую половину r13
    shr r9, 32
    shr r11, 32
    mov eax, r9d
    mul1x32 r11d
    shl rax, 32
    or  r13, rax

    mov [rcx], r12
    mov [rcx+8], r13

    pop r14
    pop r13
    pop r12
    pop rbx

    ret
mul4x32 ENDP
END